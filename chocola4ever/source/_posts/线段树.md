title: 线段树
author: Chocola4ever
tags:
  - 线段树
categories:
  - 算法
date: 2021-03-27 21:33:00
---
# 模板题

- [线段树1](https://www.luogu.com.cn/problem/P3372)
- [线段树2](https://www.luogu.com.cn/problem/P3373)
- [线段树3](https://www.luogu.com.cn/problem/P6242)

# 部分代码

```cpp
/*
	Author: Chocola4ever
	Date: 2021-03-20 08:23:12
	LastEditTime: 2021-03-20 09:49:06
	FilePath: \Programs\线段树.cpp
	Description: RP++
*/
#include<bits/stdc++.h>
#define ll long long
#define int long long
#define inf 0x3f3f3f3f
#define N 100005
using namespace std;
inline ll read(){
	ll x=0,w=1;
	char ch=getchar();
	for (;!isdigit(ch);ch=getchar())
		if (ch=='-')
			w=-1;
	for (;isdigit(ch);ch=getchar())
		x=x*10+(ch-'0');
	return x*w;
}
int a[N];
ll segt[N<<2],lztag[N<<2];
inline void build(int l,int r,int k){
	if (l==r){
		segt[k]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,k<<1);
	build(mid+1,r,(k<<1)|1);
	segt[k]=segt[k<<1]+segt[(k<<1)|1];
}
inline void pushdown(int l,int r,int k){
	int mid=(l+r)>>1;
	segt[k<<1]+=lztag[k]*(mid-l+1);
	segt[(k<<1)|1]+=lztag[k]*(r-mid);
	lztag[k<<1]+=lztag[k];
	lztag[(k<<1)|1]+=lztag[k];
	lztag[k]=0;
}
inline ll getsum(int L,int R,int l,int r,int k){
	if (L<=l&&r<=R) return segt[k];
	int mid=(l+r)>>1;
	if (lztag>0) pushdown(l,r,k);
	ll sum=0;
	if (L<=mid) sum+=getsum(L,R,l,mid,k<<1);
	if (R>=mid+1) sum+=getsum(L,R,mid+1,r,(k<<1)|1);
	return sum;
}
inline void update(int L,int R,int l,int r,int plus,int k){
	if (L<=l&&r<=R){
		segt[k]+=plus*(r-l+1);
		lztag[k]+=plus;
		return;
	}
	int mid=(l+r)>>1;
	if (lztag[k]>0&&l!=r) pushdown(l,r,k);
	if (L<=mid) update(L,R,l,mid,plus,k<<1);
	if (R>=mid+1) update(L,R,mid+1,r,plus,(k<<1)|1);
	segt[k]=segt[k<<1]+segt[(k<<1)|1];
}
signed main(){
	int n=read(),m=read();
	for (int i=1;i<=n;++i)
		a[i]=read();
	build(1,n,1);
	for(int i=1;i<=m;++i){
		int opt=read(),x=read(),y=read();
		if (opt==1){
			int k=read();
			update(x,y,1,n,k,1);
		}
		if (opt==2)
			printf("%lld\n",getsum(x,y,1,n,1));
	}
	return 0;
}
```