title: 树的重心与直径
author: Chocola4ever
tags:
  - 树上问题
  - 模板
categories:
  - 算法
date: 2021-03-29 17:59:00
---
## 树的重心

```cpp
#include<bits/stdc++.h>
#define MAXN 10005
using namespace std;
struct {
    int to,nxt,val;
}e[MAXN];
int head[MAXN],tot=1,n;
int sz[MAXN];//sz(size)存子树大小
int wght[MAXN];//wght(weight)存最大子树的节点个数
int G[2];//G为重心(最多2个,存0 or 1)
void akioi(int x,int y){
    e[++tot].to=y;
    e[tot].nxt=head[x];
    head[x]=tot;
} 
void orz(int u,int fa){
    sz[u]=1;
    wght[u]=0;
    for (int i=head[u];i;i=e[i].nxt){
        if (e[i].to!=fa){
            orz(e[i].to,u);
            sz[u]+=sz[e[i].to];//加上孩子节点的子树个数 
            wght[u]=max(wght[u],sz[e[i].to]);
        }
    }
    wght[u]=max(wght[u],n-sz[u]);//n-sz[u]为"向上"子树 
    if (wght[u]<=n/2)
        G[G[0]!=0]=u;
}
orz(1,-1);
```

## 树的直径
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,tot=0,dist,maxdist,maxn;
int head[100005];
bool vis[100005];
struct tr{
    int nxt,to,val;
}e[100005];
void addedge(int x,int y,int z){
    e[++tot].to=y;
    e[tot].nxt=head[x];
    e[tot].val=z;
    head[x]=tot; 
}
void dfs(int u){
    vis[u]=1;
    if (dist>maxdist){
        maxdist=dist;
        maxn=u;
    }
    for (int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if (!vis[v]){
            dist+=e[i].val;
            dfs(v);
            dist-=e[i].val;
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        addedge(x,y,z);
        addedge(y,x,z);
    }
    dist=0;
    maxdist=-INT_MAX;
    dfs(1);
    memset(vis,0,sizeof(vis));
    dist=0;
    maxdist=-INT_MAX;
    dfs(maxn);//两遍dfs 
    cout<<maxdist<<endl;
    return 0;
}
```