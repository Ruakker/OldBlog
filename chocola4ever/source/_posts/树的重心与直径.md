title: 树的重心与直径
author: Chocola4ever
tags:
  - 树上问题
  - 模板
categories:
  - 算法
date: 2021-03-29 17:59:00
---
## 树的重心

```cpp
struct {
	int to,nxt,val;
}e[N];
int head[N],tot=1,n;
int sz[N];//sz(size)存子树大小
int wght[N];//wght(weight)存最大子树的节点个数
int G[2];//G为重心(最多2个,存0 or 1)
void dfs(int u,int fa){
	sz[u]=1;
	wght[u]=0;
	for (int i=head[u];i;i=e[i].nxt){
		if (e[i].to!=fa){
			dfs(e[i].to,u);
			sz[u]+=sz[e[i].to];//加上孩子节点的子树个数
			wght[u]=max(wght[u],sz[e[i].to]);
		}
	}
	wght[u]=max(wght[u],n-sz[u]);//n-sz[u]为"向上"子树
	if (wght[u]<=n/2)
		G[G[0]!=0]=u;
}
int main(){
//	...
	dfs(1,-1);
//	...
}
```

## 树的直径
```cpp
int n,m,tot=0,dist,maxdist,maxn;
int head[N];
bool vis[N];
struct tr{
	int nxt,to,val;
}e[N];
void dfs(int u){
	vis[u]=1;
	if (dist>maxdist){
		maxdist=dist;
		maxn=u;
	}
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!vis[v]){
			dist+=e[i].val;
			dfs(v);
			dist-=e[i].val;
		}
	}
}
int main(){
//	...
	dist=0;
	maxdist=-INT_MAX;
	dfs(1);
	memset(vis,0,sizeof(vis));
	dist=0;
	maxdist=-INT_MAX;
	dfs(maxn);//两遍dfs
	printf("%d",maxdist);
//	...
}
```