---
title: 关于图论的一些模板
author: Chocola4ever
tags:
  - 图论
  - Dijkstra
  - Kruskal
  - Tarjan
  - 缩点
  - 树上问题
  - 最短路径
  - 最小生成树
  - 树链剖分
  - 模板
categories:
  - 算法
date: 2021-03-30 10:33:00
---

> 整理了一些图论常用的模板，以后可能还会更新

## Dijkstra

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
int dis[N],a[N][N];
bool b[N];
inline void dijkstra(int p0){
	for (int i=1;i<=n;i++)
		dis[i]=a[p0][i];
	b[p0]=1;
	dis[p0]=0;
	for (int i=1;i<=n-1;i++){
		minv=inf;
		int v=0;
		for (int j=1;j<=n;j++)
			if (!b[j] && dis[j]<minv){
				minv=dis[j];
				v=j;
			}
		if (v==0)
			break;
		b[k]=true;
		for (int j=1;j<=n;j++)
			dis[j]=min(dis[j],a[v][j]+dis[v]);
	}
}
int main(){
//	...
	for (int i=1;i<=n;i++)
		for (int i=1;i<=n;i++)
			a[i][j]=inf;
//	read
//	...
}
```

## Kruskal

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct point{
	ll x,y,v;
}e[1005];
int fa[1005];
int n,i,j,x,y,z,m,tot,k;
inline int father(int x){
	if (fa[x]!=x) fa[x]=father(fa[x]);
	return fa[x];
}
void unionn(int x,int y){
	int faa=father(x);
	int fab=father(y);
	if (faa!=fab) fa[faa]=fab;
}
bool cmp(point x,point y){return x.v<y.v;}
void kruskal(){
	for (i=1;i<=m;i++){
		if (father(e[i].x)!=father(e[i].y)){
			unionn(e[i].x,e[i].y);
			tot+=e[i].v;
			k++;
		}
		if (k==n-1) break;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		e[i].x=x,e[i].y=y,e[i].v=z;
	}
	for (i=1;i<=n;i++)
		fa[i]=i;
	sort(e+1,e+m+1,cmp);
	kruskal();
	cout<<tot<<endl;
	return 0;
}
```

## Tarjan

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt=0,cnte=0,newcnt=0,n,m,head[5*N],outdgr[N],dfn[N],low[N],inst[N],id[N],sz[N];
inline void tarjan(int u){
	dfn[u]=++cnt;
	low[u]=cnt;
	inst[u]=1;
	st.push(u);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		} else if (inst[v])
			low[u]=min(low[u],dfn[v]);
	}
	int v;
	if (dfn[u]==low[u]){
		newcnt++;
		do{
			v=st.top();
			st.pop();
			inst[v]=0;
			id[v]=newcnt;
			sz[newcnt]++;
		} while (v!=u);
	}
}
int main(){
//	...
}
//求边双点双割边割点不走回父亲
inline void tarjan(int u,int pre){
	dfn[u]=++cnt;
	low[u]=cnt;
	inst[u]=1;
	st.push(u);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v!=pre){
			if (!dfn[v]){
				tarjan(v,u);
//			  if (low[v]>=dfn[u])
//				  cutpoint[++cnt1]=u; 割点u
				low[u]=min(low[u],low[v]);
			} else if (inst[v])
				low[u]=min(low[u],dfn[v]);
		}
	}
	int v;
	if (dfn[u]==low[u]){
		newcnt++;
		do{
			v=st.top();
			st.pop();
			inst[v]=0;
			id[v]=newcnt;
			sz[newcnt]++;
		}while (v!=u);
	}
}
```

## 树链剖分

```cpp
#include<bits/stdc++.h>
#define MAXN 10005
using namespace std;
int sz[MAXN],f[MAXN],dep[MAXN],head[MAXN];
struct{
	int nxt,to,val;
}e[MAXN];
void dfs1(int u){//一遍dfs求sz,dep,f(子树大小,深度,父亲)
	sz[u]=1;
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!dep[v])
		{
			dep[v]=dep[u]+1;
			f[v]=u;
			dfs1(v);
			sz[u]+=sz[v];
			if (sz[v]>sz[son[u]])
				son[u]=v;
		}
	}
}
void dfs2(int u,int chain){//第二遍dfs求anc和p(u所在重链顶结点,树链剖分序)
	p[u]=++cnt;
	anc[u]=chain;
	if (!son[u])
		return;
	dfs2(son[u],chain);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (dep[v]>dep[u]&&v!=son[u])
			dfs2(v,v);
	}
}
int lca(int u,int v){//树链剖分求lca最近公共祖先
	while (anc[u]!=anc[v]){
		if (dep[anc[u]]>dep[anc[v]])
			u=f[anc[u]];
		else
			v=f[anc[v]];
	}
  return dep[u]>dep[v]?v:u;
}
int main(){
//	...
	cnt=0;
	dfs1(1);
	dfs2(1,1);
//	...
}
```

## 树的重心

```cpp
struct {
	int to,nxt,val;
}e[N];
int head[N],tot=1,n;
int sz[N];//sz(size)存子树大小
int wght[N];//wght(weight)存最大子树的节点个数
int G[2];//G为重心(最多2个,存0 or 1)
void dfs(int u,int fa){
	sz[u]=1;
	wght[u]=0;
	for (int i=head[u];i;i=e[i].nxt){
		if (e[i].to!=fa){
			dfs(e[i].to,u);
			sz[u]+=sz[e[i].to];//加上孩子节点的子树个数
			wght[u]=max(wght[u],sz[e[i].to]);
		}
	}
	wght[u]=max(wght[u],n-sz[u]);//n-sz[u]为"向上"子树
	if (wght[u]<=n/2)
		G[G[0]!=0]=u;
}
int main(){
//	...
	dfs(1,-1);
//	...
}
```

## 树的直径
```cpp
int n,m,tot=0,dist,maxdist,maxn;
int head[N];
bool vis[N];
struct tr{
	int nxt,to,val;
}e[N];
void dfs(int u){
	vis[u]=1;
	if (dist>maxdist){
		maxdist=dist;
		maxn=u;
	}
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!vis[v]){
			dist+=e[i].val;
			dfs(v);
			dist-=e[i].val;
		}
	}
}
int main(){
//	...
	dist=0;
	maxdist=-INT_MAX;
	dfs(1);
	memset(vis,0,sizeof(vis));
	dist=0;
	maxdist=-INT_MAX;
	dfs(maxn);//两遍dfs
	printf("%d",maxdist);
//	...
}
```

## 缩点

### 有向图缩点

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
struct{
	int nxt,to;
}e[N*5];
stack<int> st;
stack<int> st1;
int head[N*5],dfn[N],low[N],id[N],u1[N*5],v1[N*5],sz[N];
bool inst[N];
int newcnt,cnt,totedge,n,m;
inline void addedge(int x,int y){
	e[++totedge].to=y;
	e[totedge].nxt=head[x];
	head[x]=totedge;
}
inline void tarjan(int u){
	dfn[u]=++cnt;
	low[u]=cnt;
	inst[u]=1;
	st1.push(u);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		} else if (inst[v])
			low[u]=min(low[u],dfn[v]);
	}
	int v;
	if (dfn[u]==low[u]){
		newcnt++;
		do{
			v=st1.top();
			st1.pop();
			inst[v]=0;
			id[v]=newcnt;
			sz[newcnt]++;
		}while (v!=u);
	}
}
int main(){
//	...
	for (int i=1;i<=n;i++)
		if (!dfn[i])
			tarjan(i);
	memset(e,0,sizeof(e));
	memset(head,0,sizeof(head));
	totedge=0;
	for (int i=1;i<=m;i++)
		if (id[u1[i]]!=id[v1[i]])
			addedge(id[u1[i]],id[v1[i]]);
//	...
}
```

### 无向图缩点

```cpp
#include<bits/stdc++.h>
#define N 300005
#define inf 0x3f3f3f3f
using namespace std;
struct{
	int nxt,to;
}e[N*2];
stack<int> st;
stack<int> st1;
int head[N*2],dfn[N],low[N],id[N],u1[N],v1[N],sz[N];
bool inst[N],vis[N];
int newcnt,cnt,totedge,n,m,dist,maxdist,maxn;
inline void addedge(int x,int y){
	e[++totedge].to=y;
	e[totedge].nxt=head[x];
	head[x]=totedge;
}
inline void tarjan(int u,int pre){
	dfn[u]=++cnt;
	low[u]=cnt;
	inst[u]=1;
	st1.push(u);
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (v==pre) continue;
		if (!dfn[v]){
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
		} else if (inst[v])
			low[u]=min(low[u],dfn[v]);
	}
	int v;
	if (dfn[u]==low[u]){
		newcnt++;
		do{
			v=st1.top();
			st1.pop();
			inst[v]=0;
			id[v]=newcnt;
			sz[newcnt]++;
		} while (v!=u);
	}
}
inline void dfs(int u){
	vis[u]=1;
	if (dist>maxdist)
		maxdist=dist,maxn=u;
	for (int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if (!vis[v]){
			dist++;
			dfs(v);
			dist--;
		}
	}
}
int main(){
//	...
	for (int i=1;i<=n;i++)
		if (!dfn[i])
			tarjan(i,-1);
	memset(e,0,sizeof(e));
	memset(head,0,sizeof(head));
	totedge=0;
	for (int i=1;i<=m;i++)
		if (id[u1[i]]!=id[v1[i]]){
			addedge(id[u1[i]],id[v1[i]]);
			addedge(id[v1[i]],id[u1[i]]);
		}
//	...
}
```