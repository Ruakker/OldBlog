---
title: CF1008C 题解
author: Chocola4ever
date: 2021-04-14 15:44:32
tags: 题解
---

## [题目](https://www.luogu.com.cn/problem/CF1008C)大意

>   给定一个序列，序列里的元素可以以任意顺序重新排好。
>
>   序列里某位置排序后的数可能会大于原数，问这样的位置最多能有多少个？

## 思路

首先，要想达到**排列后大于原数的位置的个数**最多，可以考虑将次小的数放在最小的位置上，将第三小的数放在次小的位置上 $\dots$

我们先把数列从小到大排序，然后从左到右扫一遍，当 $a_{i-1}<a_i$ 时，就说明 $a_i$ 可以放到 $a_{i-1}$ 上。

但是这会有一个问题：如何处理**相同的数**？

显然，这种方法通过不了这组数据：

```
6
1 1 1 2 3 3
```

正解答案为 $3$ ，而这种方法只能得到答案 $2$ 

**问题出在什么地方？**

我们需要将数字**尽可能向左地**匹配，而不是每次只尝试匹配 $a_{i-1}$ ，这样就能得到最大答案。

## 题解

我们先将整个数列**从小到大**排序，然后定义一个 $cnt$ ，当 $a_{cnt}<a_i$ 时，说明我们可以把 $a_i$ 放到 $a_{cnt}$ 的位置上。

核心代码：

```cpp
int cnt=1,ans=0;
sort(a+1,a+1+n);//从小到大排序
for (int i=1;i<=n;++i)
	if (a[i]>a[cnt])
		++cnt,++ans;
```